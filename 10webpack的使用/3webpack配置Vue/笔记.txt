安装vue npm install vue --save 
vue是运行和开发都需要的,所以不使用 --save-dev
{
  "name": "meetwebpack",
  "version": "1.0.0",
  "description": "styduing",
  "main": "webpack.config.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "webpack"
  },
  "author": "huhusw",
  "license": "ISC",
  "devDependencies": {
    "css-loader": "^3.4.2",
    "file-loader": "^5.0.2",
    "style-loader": "^1.1.3",
    "url-loader": "^3.0.0",
    "webpack": "^4.41.6",
    "webpack-cli": "^3.3.11"
  },
  运行时依赖
  "dependencies": {
    "vue": "^2.6.11"
  }
}

在需要使用到vue的文件下import Vue from "vue",就可以建vue实例
但是在实践过程中发现,这个方式并不能使创建的实例得到响应
直接引用vue.js文件也不能解决实例的问题,控制台找不到vue实例,但是代码中却可以调用实例的方法

引用vue会出现两种情况
runtime-only     ：代码中不能含有任何template 修改配置可以转到compiler
runtime-compiler ：代码中可以含有template，compiler会进行编译template

在开发中，一般的index.html不希望被频繁修改，所以index中的代码尽量简洁
可以将html中的div中显示的元素放在vue实例中的template属性中
el和template的配合使用，vue会将template中的元素放在el挂载的元素上

现在发现vue实例的代码越来越多，这不是一个好兆头
抽离出臃肿的代码可以使代码看起来简洁
原始版本==》抽离后的版本，tempalt、data、methods都被抽离出去当成一个组件
然后在实例中注册这个需要的组件，在template中进行使用

但是发现一个js文件中包含不同的代码，于是想到分文件操作
将组件抽离到app.js文件中，再导出
导入进行使用
但是在js文件中，js代码和html代码并没有进行分离，下面将其分离
新建vue文件，放置组件代码
编译vue文件需要安装相关的包，否则编译不通过
npm install --save-dev vue-loader vue-template-compiler
下载好进行配置vue-loader
报错：vue-loader was used without the corresponding plugin. Make sure to include VueLoaderPlugin in your webpack
没有使用正确的插件，这是loader版本的问题，可以下调vue-loader的版本,此解决办法并不管用
下调版本后发现vue not defined错误，查了一圈，应该是版本匹配的问题
还是将vue-loader的插件装上比较好
// vue-loader的插件
const VueLoaderPlugin = require('vue-loader/lib/plugin');
{
	plugins: [
		// make sure to include the plugin for the magic
		new VueLoaderPlugin()
	],
}

那么